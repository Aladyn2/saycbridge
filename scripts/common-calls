#!/usr/bin/env python
# Copyright (c) 2013 The SAYCBridge Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import sys
import find_src
import collections

from z3b.bidder import Bidder, Interpreter, InconsistentHistoryException
from z3b.model import expr_for_hand, positions
from core.callhistory import CallHistory
from core.deal import Deal
from core.callexplorer import CallExplorer


if __name__ == '__main__':
    args = sys.argv[1:]
    bidder = Bidder()
    interpreter = Interpreter()
    call_history = CallHistory.from_string(" ".join(args))

    history = interpreter.create_history(call_history)

    possible_call_to_history = {}
    for call in CallExplorer().possible_calls_over(call_history):
        try:
            possible_call_to_history[call] = interpreter.extend_history(history, call)
        except InconsistentHistoryException:
            continue

    call_counts = collections.Counter()
    for _ in range(100):
        # Random is random.  We don't care which hand is which.
        deal = Deal.random()
        if all(history.is_consistent(position, expr_for_hand(hand)) for hand, position in zip(deal.hands, positions)):
            hand_expr = expr_for_hand(deal.hands[positions.LHO.index])
            for call, possible_history in possible_call_to_history.items():
                if possible_history.is_consistent(positions.Me, hand_expr):
                    call_counts[call] += 1

    for call_and_count in call_counts.most_common():
        call, count = call_and_count
        if not call:
            print "%2s: %s (%s)" % (None, count, None)
            continue

        # FIXME: We would not need to re-interpret the bids if Bidder had a find_call_for which returned a History.
        call_name = call.name
        history = interpreter.create_history(call_history.copy_appending_call(call))
        rule = history.rho.rule_for_last_call
        print "%2s: %s (%s)" % (call_name, count, rule)
