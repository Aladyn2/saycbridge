#!/usr/bin/env python
# Copyright (c) 2013 The SAYCBridge Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import sys
import find_src

from core.callhistory import CallHistory
from z3b.bidder import Interpreter, RuleSelector
from core.callexplorer import CallExplorer
from z3b import model
import z3


def _print_usage_and_exit():
    print "USAGE: none-finder HISTORY"
    print " HISTORY is space or comma separated"
    print
    sys.exit(1)


def _decl_cmp(*args):
    names = map(lambda key: key.name(), args)
    # Sort names without _ in them to the top.
    are_primary = map(lambda name: name.find("_") != -1, names)
    cmp_result = cmp(*are_primary)
    if cmp_result:
        return cmp_result
    return cmp(*names)

def _pretty_print_model(model):
    for decl in sorted(model.decls(), cmp=_decl_cmp):
        print "%s: %s" % (decl, model[decl])


class NoneFinder(object):
    def main(self):
        history_string = " ".join(sys.argv[1:])
        call_history = CallHistory.from_string(history_string)

        interpreter = Interpreter()
        history = interpreter.create_history(call_history)
        selector = RuleSelector(interpreter.system, history)

        constraints = []
        for call in CallExplorer().possible_calls_over(call_history):
            rule = selector.rule_for_call(call)
            if rule and not rule.requires_planning(history):
                constraints.append(selector.constraints_for_call(call))

        constraints_expr = z3.Not(z3.Or(*constraints))
        solver = z3.SolverFor('QF_LIA')
        solver.add(model.axioms)
        solver.add(constraints_expr)

        if solver.check() == z3.unsat:
            print "Calls found for all possible hands."
        else:
            print "Unbiddable hand:"
            _pretty_print_model(solver.model())


if __name__ == '__main__':
    NoneFinder().main()
